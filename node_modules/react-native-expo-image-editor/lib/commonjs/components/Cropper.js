"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireWildcard(require("react"));

var _reactNative = require("react-native");

var _Cropper = _interopRequireDefault(require("../styles/Cropper.style"));

var _Grid = _interopRequireDefault(require("./Grid/Grid"));

var _utils = require("./utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var Direction;

(function (Direction) {
  Direction[Direction["NONE"] = 0] = "NONE";
  Direction[Direction["NORMAL"] = 1] = "NORMAL";
  Direction[Direction["LEFT"] = 2] = "LEFT";
  Direction[Direction["RIGHT"] = 3] = "RIGHT";
  Direction[Direction["TOP"] = 4] = "TOP";
  Direction[Direction["BOTTOM"] = 5] = "BOTTOM";
  Direction[Direction["TOP_LEFT"] = 6] = "TOP_LEFT";
  Direction[Direction["TOP_RIGHT"] = 7] = "TOP_RIGHT";
  Direction[Direction["BOTTOM_LEFT"] = 8] = "BOTTOM_LEFT";
  Direction[Direction["BOTTOM_RIGHT"] = 9] = "BOTTOM_RIGHT";
})(Direction || (Direction = {}));

class Cropper extends _react.default.Component {
  constructor(props) {
    super(props); // Initial State

    _defineProperty(this, "panResponder", void 0);

    _defineProperty(this, "gridRef", /*#__PURE__*/(0, _react.createRef)());

    _defineProperty(this, "pan", void 0);

    _defineProperty(this, "boxWidth", void 0);

    _defineProperty(this, "boxHeight", void 0);

    this.state = {
      direction: Direction.NONE,
      initialWidth: props.imageWidth,
      initialHeight: props.imageHeight,
      initialLeft: 0,
      initialTop: 0
    }; // ==============================
    // Ref for grid component

    this.gridRef = /*#__PURE__*/_react.default.createRef(); // ==========================
    // Initial Pan

    this.pan = new _reactNative.Animated.ValueXY({
      x: 0,
      y: 0
    }); // ==========================
    // === Box Animated Width & Height ===

    this.boxWidth = new _reactNative.Animated.Value(props.imageWidth);
    this.boxHeight = new _reactNative.Animated.Value(props.imageHeight); // ==========================
    // === Initialize pan responder ===

    this.onPanResponderGrant = this.onPanResponderGrant.bind(this);
    this.onPanResponderMove = this.onPanResponderMove.bind(this);
    this.onPanResponderEnd = this.onPanResponderEnd.bind(this); // this.getCroppedData = this.getCroppedData.bind(this);

    this.panResponder = _reactNative.PanResponder.create({
      onMoveShouldSetPanResponder: () => true,
      onPanResponderTerminationRequest: () => true,
      onPanResponderGrant: this.onPanResponderGrant,
      onPanResponderMove: this.onPanResponderMove,
      onPanResponderTerminate: this.onPanResponderEnd,
      onPanResponderRelease: this.onPanResponderEnd
    }); //  ==========================
  }
  /**
   *
   * Reset the cropper to initial state
   * @memberof Cropper
   */


  reset() {
    const {
      imageWidth,
      imageHeight
    } = this.props;
    this.boxWidth.setValue(imageWidth);
    this.boxHeight.setValue(imageHeight);
    this.pan.setOffset({
      x: 0,
      y: 0
    });
    this.setState({
      initialTop: 0,
      initialLeft: 0,
      initialWidth: imageWidth,
      initialHeight: imageHeight
    });
  }

  onPanResponderEnd() {
    const {
      initialTop,
      initialLeft
    } = this.state;
    this.setState({
      initialWidth: this.boxWidth._value,
      initialHeight: this.boxHeight._value,
      initialTop: initialTop + this.pan.y._value,
      initialLeft: initialLeft + this.pan.x._value
    });
    this.pan.flattenOffset();
    this.pan.setValue({
      x: 0,
      y: 0
    });
  }

  onPanResponderMove(event, gestureState) {
    const {
      dx: ndx,
      dy: ndy
    } = gestureState;
    const {
      direction,
      initialLeft,
      initialTop,
      initialWidth,
      initialHeight
    } = this.state;
    const {
      originX
    } = this.props;
    let dx = 0;
    let dy = 0;
    let dw = 0;
    let dh = 0;

    switch (direction) {
      case Direction.LEFT:
        dx = ndx;
        dy = 0;
        dw = initialWidth - dx;
        dh = initialHeight;
        break;

      case Direction.RIGHT:
        dx = 0;
        dy = 0;
        dw = initialWidth + ndx;
        dh = initialHeight;
        break;

      case Direction.TOP:
        dx = 0;
        dy = ndy;
        dw = initialWidth;
        dh = initialHeight - ndy;
        break;

      case Direction.BOTTOM:
        dx = 0;
        dy = 0;
        dw = initialWidth;
        dh = initialHeight + ndy;
        break;

      case Direction.TOP_LEFT:
        dx = ndx;
        dy = ndy;
        dw = initialWidth - ndx;
        dh = initialHeight - ndy;
        break;

      case Direction.TOP_RIGHT:
        dx = 0;
        dy = ndy;
        dw = initialWidth + ndx;
        dh = initialHeight - ndy;
        break;

      case Direction.BOTTOM_LEFT:
        dx = ndx;
        dy = 0;
        dw = initialWidth - ndx;
        dh = initialHeight + ndy;
        break;

      case Direction.BOTTOM_RIGHT:
        dx = 0;
        dy = 0;
        dw = initialWidth + ndx;
        dh = initialHeight + ndy;
        break;

      default:
        if (ndx + initialLeft + initialWidth >= this.props.imageWidth) dx = this.props.imageWidth - initialLeft - initialWidth;else dx = ndx;
        if (ndy + initialTop + initialHeight >= this.props.imageHeight) dy = this.props.imageHeight - (initialTop + initialHeight);else dy = ndy;
        dw = initialWidth;
        dh = initialHeight;
    }

    if (initialLeft + dx <= originX) dx = -initialLeft;
    if (initialTop + dy <= 0) dy = -initialTop;
    if (dw + initialLeft >= this.props.imageWidth) dw = this.props.imageWidth - initialLeft;
    if (dh + initialTop > this.props.imageHeight) dh = this.props.imageHeight - initialTop;
    return _reactNative.Animated.event([null, {
      dx: this.pan.x,
      dy: this.pan.y,
      dw: this.boxWidth,
      dh: this.boxHeight
    }], {
      useNativeDriver: false
    })(event, {
      dx,
      dy,
      dw,
      dh
    });
  }

  onPanResponderGrant(_, gestureState) {
    const {
      moveX,
      moveY
    } = gestureState;
    console.log('giant');
    this.gridRef.current.measure((_fx, _fy, width, height, px, py) => {
      const xPan = Math.floor((moveX - px) / (width / 3));
      const yPan = Math.floor((moveY - py) / (height / 3));
      this.setState({
        direction: this.getDirection(xPan, yPan)
      });
    });
    this.pan.setOffset({
      x: this.pan.x._value,
      y: this.pan.y._value
    });
  }

  async getCroppedData(uri) {
    const {
      initialTop,
      initialWidth,
      initialHeight,
      initialLeft
    } = this.state;
    const {
      imageWidth,
      imageHeight
    } = this.props;
    const {
      width: actualWidth,
      height: actualHeight
    } = await (0, _utils.getImageSize)(uri);
    const scaleX = actualWidth / imageWidth;
    const scaleY = actualHeight / imageHeight;
    return {
      originX: initialLeft * scaleX,
      originY: initialTop * scaleY,
      width: initialWidth * scaleX,
      height: initialHeight * scaleY
    };
  }

  getDirection(xPos, yPos) {
    const index = Math.floor(yPos * 3 + xPos);

    switch (index) {
      case 0:
        return Direction.TOP_LEFT;

      case 1:
        return Direction.TOP;

      case 2:
        return Direction.TOP_RIGHT;

      case 3:
        return Direction.LEFT;

      case 4:
        return Direction.NORMAL;

      case 5:
        return Direction.RIGHT;

      case 6:
        return Direction.BOTTOM_LEFT;

      case 7:
        return Direction.BOTTOM;

      case 8:
        return Direction.BOTTOM_RIGHT;

      default:
        return Direction.NORMAL;
    }
  }

  render() {
    var _this$panResponder;

    const {
      children,
      imageHeight,
      imageWidth,
      originX
    } = this.props;

    const getGirdAnimatedStyle = () => {
      return {
        width: this.boxWidth,
        height: this.boxHeight,
        zIndex: 100,
        left: originX,
        transform: [{
          translateX: _reactNative.Animated.add(this.pan.x, this.state.initialLeft)
        }, {
          translateY: _reactNative.Animated.add(this.pan.y, this.state.initialTop)
        }]
      };
    };

    return [children, /*#__PURE__*/_react.default.createElement(_reactNative.View, {
      key: 'Grid',
      style: [{
        width: imageWidth,
        height: imageHeight
      }, _Cropper.default.container]
    }, /*#__PURE__*/_react.default.createElement(_reactNative.Animated.View, _extends({
      ref: this.gridRef,
      style: getGirdAnimatedStyle()
    }, (_this$panResponder = this.panResponder) === null || _this$panResponder === void 0 ? void 0 : _this$panResponder.panHandlers), /*#__PURE__*/_react.default.createElement(_Grid.default, null)))];
  }

}

var _default = Cropper;
exports.default = _default;
//# sourceMappingURL=Cropper.js.map